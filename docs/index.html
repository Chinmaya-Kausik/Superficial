<h1>Superficial</h1>

<p>Identifying simple closed curves over an orientable surface (topology).</p>

<h2>Implemented</h2>

<p>An <a href="Reference.pdf">algorithm</a> given by D.R.J. Chillingworth, that determines whether a given element of <a href="https://en.wikipedia.org/wiki/Fundamental_group">Funamental Group</a> of an <a href="https://en.wikipedia.org/wiki/Orientability">orientable</a> surface which is not a sphere; can be represented by a <a href="http://www.mathwords.com/s/simple_closed_curve.htm">simple</a> closed curve.</p>

<h2>Getting Started</h2>

<h3>Setting Things Up</h3>

<p>One needs to install <a href="http://www.scala-sbt.org/release/docs/Setup.html">sbt</a> first and then should follow following steps:
* Clone this repository and move to home directory of this project as below,
<code>
$ cd Superficial
</code>
* Run sbt-update once as below, to install the required scala version
<code>
$ sbt update
</code>
* And compile the source code (being present at the project home directory) before running as below,
<code>
$ sbt compile
</code></p>

<h3>Running the code</h3>

<p>At present, only way of running this sbt project is through sbt-console. However, it can be used as an unmanaged dependency after packaging it to a .jar file using <code>sbt package</code> command.</p>

<p>Following are the steps to run on the sbt-console;
* Move to the project directory.
* Lauch console as below from the project directory, as below
<code>
$ sbt console
</code>
* Then import the source code to the console as below and get going,
```</p>

<blockquote>
  <p>import superficial._
```</p>
</blockquote>

<h2>Documentation</h2>

<p>Source code includes:
* a trait <code>Generator</code> with classes <code>a(i)</code>, <code>b(i)</code> and <code>s(i)</code> (each indexed) extending it.
* a type alias <code>Word</code> which is <code>Vector[Generator]</code>.
* a class <code>OrientableSurface(g,r)</code> which takes a integer argument <code>g</code> as the genus and another integer argument <code>r</code> which is the number of components in the boundary. Following are its notable methods:
     * <code>red1(w: Word): Word</code> -- performs cyclic reduction
     * <code>reduce(w: Word): Word</code> -- performs complete reduction
     * <code>satisfyEquation(w: Word,0,0): Boolean</code> -- checks division property (for correctness other arguments should be zero.)
     * <code>isSimple(w: Word): Boolean</code> -- checks if w is simple closed curve</p>

<h2>Demo and Results</h2>

<p>Refer to <a href="superficial.ipynb">demo</a> for some code demo and also some results involving computing approximate fraction of words of fixed length, which are homotopic to simple closed curve.</p>

<h2>Acknowledgments</h2>

<ul>
<li><a href="https://github.com/siddhartha-gadgil">Prof. Siddhartha Gadgil</a></li>
<li><a href="http://www.scala-lang.org/api/2.12.0/index.html">Scala Standard Library</a></li>
</ul>
